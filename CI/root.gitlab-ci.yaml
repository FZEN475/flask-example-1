spec:
  inputs:
    merge_branch_action:
      options: [ 'skip', 'delete' ]
      type: string
      default: 'skip'
# вот что далее думаю излишни. эти параметры можно покрывать простыми условиями
    # docker_builder:
    #   type: boolean
    #   default: false
    # helm_builder:
    #   type: boolean
    #   default: false
    # helm_deploy:
    #   type: boolean
    #   default: false
---

.template-variables: &template-variables
  variables:
    NS: prod
    RELEASE_NAME: "${CI_PROJECT_NAME}"
    CHANNEL: release
    KUBE_CONTEXT: dev/kubernetes-agent-config:kubernetes-agent-prod
    IMAGE_TAG: latest
    INGRESS_CLASS_NAME: external-nginx
    HOST: "${CI_PROJECT_NAME}.fzen.pro"

.template-rules: &template-rules
  if: $CI_PIPELINE_SOURCE == "web" || $CI_PIPELINE_SOURCE == "merge_request_event" || $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_REF_PROTECTED == "true"
  <<: *template-variables

workflow:
  auto_cancel:
    on_job_failure: all

stages:
  - build
  - push
  - deploy

docker_builder:build:job:
  stage: build
  script:
    - >
      echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}"
      > /kaniko/.docker/config.json
    - cat /kaniko/.docker/config.json
    - >
      /kaniko/executor
      --context "${CI_PROJECT_DIR}"
      --dockerfile "${CI_PROJECT_DIR}/Dockerfile"
      --no-push
      --skip-tls-verify
      --tar-path image.tar
      --cache=true --cache-repo="${CI_REGISTRY_IMAGE}/cache"
  artifacts:
    paths:
      - image.tar
  tags:
    - docker-builder
  rules:
    - *template-rules
# на мой взгляд лишний переключатель
    # - if: '"$[[ inputs.docker_builder ]]" == "true"'
    #   when: always
    # - when: never


docker_builder:push:job:
  stage: push
  image:
    name: gcr.io/go-containerregistry/crane:debug
    entrypoint: [ "" ]
  variables:
    IMAGE_TAG: "${CI_COMMIT_BRANCH}"
  script:
    - ls -all image.tar
    - crane auth login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY --insecure
    - crane push image.tar ${CI_REGISTRY_IMAGE}:$IMAGE_TAG --insecure
  tags:
    - docker-builder
  rules:
    - *template-rules # на этом этапу лишнее пуш имаджа при merge_request_event. merge_request_event - обычно для провеки кода перед влитием в основную ветку, прогон тестов. Но бывают исключения
# на мой взгляд лишний переключатель
    # - if: '"$[[ inputs.docker_builder ]]" == "true"'
    #   when: always
    # - when: never
  needs: [ 'docker_builder:build:job' ]

helm_builder:test:config:job:
  stage: build
  variables:
    KUBE_CONTEXT: dev/kubernetes-agent-config:kubernetes-agent-dev
  image:
    name: alpine/helm
    entrypoint: [ "" ]
  script:
    - helm dependency build ./chart/ --debug
    - helm template ./chart/ --debug > config.yaml
    - helm lint ./chart/
    - helm lint ./chart/charts/*/ || true
  artifacts:
    paths:
      - config.yaml
  tags:
    - helm
  rules:
    - *template-rules
# на мой взгляд лишний переключатель, я бы так же завязал на template-rules. тут как раз условие merge_request_event хорошо вписывается
    # - if: '"$[[ inputs.helm_builder ]]" == "true"'
    #   when: always
    # - when: never

helm_builder:test:deploy:job:
  stage: build
  variables:
    KUBE_CONTEXT: dev/kubernetes-agent-config:kubernetes-agent-dev
  image:
    name: alpine/helm
    entrypoint: [ "" ]
  script:
    - |
      helm upgrade --install ${CI_PROJECT_NAME}-${CI_PIPELINE_ID} ./chart \                    # helm install Устанавливает новый релиз. Если релиз с таким именем уже существует, команда завершится с ошибкой.
      -n dev --create-namespace \                                                              # А если нет немспейса dev? лучше автоматизировать с --create-namespace
      -f ./chart/values.yaml \
      --set host=${CI_PROJECT_NAME}-${CI_PIPELINE_ID}.fzen.pro \
      --dry-run=server \
      --wait --kubeconfig=$KUBECONFIG --kube-context=$KUBE_CONTEXT
  tags:
    - helm
  rules:
    - *template-rules
# на мой взгляд лишний переключатель, я бы так же завязал на template-rules
    # - if: '"$[[ inputs.helm_builder ]]" == "true"'
    #   when: always
    # - when: never

#helm_builder:build:job:   # вот тут понял, что очень нечитаемые названия этапов. я бы называл по примеру ниже
build helm package:
  stage: build
  image:
    name: alpine/helm
    entrypoint: [ "" ]
  script:
    - find ./chart -type f -regex '.*\(Chart.ya\?ml\|requirements.ya\?ml\)' -exec sh -c 'helm dependency build $(dirname "{}") ' \;
    - rm -rf ./packages && mkdir -p ./packages
    - |
      echo "[PACKAGING CHART $chart]"
      helm package ./chart -d ./packages
  artifacts:
    paths:
      - packages
  tags:
    - helm
  rules:
    - *template-rules
# на мой взгляд лишний переключатель, я бы так же завязал на template-rules
  # rules:
  #   - if: '"$[[ inputs.helm_builder ]]" == "true"'
  #     when: on_success
  #   - when: never
  needs:
    - 'helm_builder:test:config:job'
    - 'helm_builder:test:deploy:job'

helm_builder:push:job:
  stage: push
  variables:
    CHANNEL: "${CI_COMMIT_BRANCH}"
  image:
    name: alpine/helm
    entrypoint: [ "" ]
  script:
    - |
      find ./packages -mindepth 1 -maxdepth 1 -type f -name '*.tgz' -exec sh -c 'basename "$0"' '{}' \; | while read package; do
        CHART_NAME=$(echo $package | sed -e 's/-[0-9]\.[0-9]\.[0-9]\.tgz$//g')
        CHART_VERSION=$(echo $package | sed -e 's/^[a-zA-Z-].*-//g' | sed -e 's/.tgz$//g')
        echo "$package"
        curl -k --request POST --form "chart=@packages/$package" --user "gitlab-ci-token:$CI_JOB_TOKEN" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/helm/api/${CHANNEL}/charts"
      done
  # sed не самая хорошая практика использовать. Я бы предложил получить CHART_NAME и CHART_VERSION на предыдущем шаге из Chart.yaml. Yaml хорошо парсится через утилиту "yq", и параметры передал через env
  # но и через sed тоже пойдет, главное что работает)
  tags:
    - helm
  rules:
    - *template-rules
    # - if: '"$[[ inputs.helm_builder ]]" == "true"'
    #   when: always
    # - when: never
  needs: [ 'helm_builder:build:job' ]

# а как деплоиться на прод? тут только dev деплой
helm:deploy:job:
  stage: deploy
  variables:
    NS: dev
    RELEASE_NAME: "${CI_COMMIT_BRANCH}-${CI_PROJECT_NAME}"
    CHANNEL: "${CI_COMMIT_BRANCH}"
    KUBE_CONTEXT: dev/kubernetes-agent-config:kubernetes-agent-dev
    IMAGE_TAG: "${CI_COMMIT_BRANCH}"
    INGRESS_CLASS_NAME: internal-nginx
    HOST: "${CI_COMMIT_BRANCH}.${CI_PROJECT_NAME}.fzen.pro"
  script:
    - |
      helm repo add $CI_PROJECT_NAME "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/helm/${CHANNEL}" \
      --username=$CI_REGISTRY_USER --password=$CI_REGISTRY_PASSWORD \
      --kubeconfig=$KUBECONFIG --kube-context=$KUBE_CONTEXT
    - |
      helm repo update && helm search repo $CI_PROJECT_NAME
    - |
      helm upgrade $RELEASE_NAME $CI_PROJECT_NAME/$CI_PROJECT_NAME --force --install --reset-then-reuse-values --debug -n $NS \
      --set image=registry.fzen.pro/dev/flask-example-1:$IMAGE_TAG \
      --set ingress.ingressClassName=$INGRESS_CLASS_NAME \
      --set host=$HOST \
      --kubeconfig=$KUBECONFIG --kube-context=$KUBE_CONTEXT
  tags:
    - helm
  needs:
    - job: helm_builder:push:job
      optional: true
    - job: docker_builder:push:job
      optional: true
  rules:
    - *template-rules
    # - if: '"$[[ inputs.helm_deploy ]]" == "true"'
    #   when: always
    # - when: never

# очень крутая тема, но в команде обычно когда создают мерж реквест и проходят все пайплайны это мерж реквест
# скидывают на рвевью коллеге. Если тот делает Approve, то мерж реквест можно вливать в основную ветку. А так круто,
# работа с api гитлаба 
auto:merge:job:
  stage: deploy
  script:
    - |
      remove_branch=false
      if [[ "$[[ inputs.merge_branch_action | expand_vars ]]" == "delete" ]]; then
        remove_branch=true
      fi
    - 'opened_merge_requests=$(curl -k -H "Authorization: Bearer $PROJECT_TOKEN" $CI_API_V4_URL/projects/"$CI_PROJECT_ID"/merge_requests?state=opened)'
    - |
      for iid in $(echo "$opened_merge_requests" | jq '.[] | .iid'); do
        curl -k --fail -X PUT -H "Authorization: Bearer $PROJECT_TOKEN" \
          -d skip_ci=true \
          $CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid/rebase      
        curl -k -X POST -H "Authorization: Bearer $PROJECT_TOKEN" \
          $CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid/approve
        curl -k -X PUT -H "Authorization: Bearer $PROJECT_TOKEN" \
          -d merge_when_pipeline_succeeds=true \
          -d should_remove_source_branch=$remove_branch \
          -d squash_commit_message="$CI_COMMIT_MESSAGE" \
          -d squash=true \
          $CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid/merge 
      done
  needs:
    - job: helm:deploy:job
      optional: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: always
    - when: never


# Очень круто, пайп хорош. Я бы обратил внимание на:
#  -  Нейминги джоб, чтобы было читаемо.
#  -  Оправдано ли использование kaniko и crane?
#  -  Все что не касается разработки приложения (хельм например), обычно выносится в другие репозитории. Часто так: репозиторий с хельм чартами и репозиторий с хельм вэльюсами. Они там собираются, пушатся.
#  -  Переклоючатели вроде  inputs.helm_deploy - никогда не пользовался. Должно быть обосновано их использование.
#  -  Нет деплоя в прод.
#  -  Можно добавить линт докер файла









